<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Favicon -->
    <link rel="shortcut icon" href="images/favicon.png" type="image/png" />
    <title>Blog</title>

    <!-- Bootstrap CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx"
      crossorigin="anonymous"
    />

    <!-- Bootstrap JS -->
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa"
      crossorigin="anonymous"
    ></script>

    <style>
      @import url("https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap");
      @import url("https://fonts.googleapis.com/css2?family=Hind+Siliguri&display=swap");
      body {
        font-family: "Hind Siliguri", sans-serif;
      }

      .text-english {
        font-family: "Poppins", sans-serif;
      }
    </style>
  </head>
  <body>
    <main class="container">
      <div
        class="row justify-content-center my-5 accordion border-0 text-start g-3"
        id="faqs"
      >
        <div class="accordion-item p-0 col-lg-8 border rounded">
          <h2 class="accordion-header m-0 border-0" id="headingOne">
            <button
              class="accordion-button collapsed"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#collapseOne"
              aria-expanded="false"
              aria-controls="collapseOne"
            >
              <span>
                <code class="text-english">localStorage</code> ও
                <code class="text-english">sessionStorage</code>-এর মধ্যে
                পার্থক্য কী?
              </span>
            </button>
          </h2>
          <div
            id="collapseOne"
            class="accordion-collapse collapse"
            aria-labelledby="headingOne"
            data-bs-parent="#faqs"
          >
            <div class="accordion-body">
              <p>
                <span class="text-english"><code>var</code>&nbsp;</span> দিয়ে
                ডিক্লেয়ার করা ভ্যারিয়েবল হলো
                <span class="text-english">Function-Scoped&nbsp;</span>(বা,
                <span class="text-english">Global Context</span>-এ
                <span class="text-english">Global-Scoped&nbsp;</span>)।
                অন্যদিকে,
                <span class="text-english"><code>let</code>&nbsp;</span> ও
                <span class="text-english"><code>const</code>&nbsp;</span> দিয়ে
                ডিক্লেয়ার করা ভ্যারিয়েবল
                <span class="text-english">Block-Scoped</span>।
              </p>
              <p>
                <span class="text-english"><code>var</code>&nbsp;</span> দিয়ে
                ডিক্লেয়ার করা ভ্যারিয়েবলের
                <span class="text-english"
                  >Declaration (But, Not the Initialization
                  Assignment)&nbsp;</span
                >
                নিজ স্কোপের শুরুতে
                <span class="text-english">Hoisted Up&nbsp;</span> হয়ে যায়।
                অন্যদিকে,
                <span class="text-english"><code>let</code>&nbsp;</span> ও
                <span class="text-english"><code>const</code>&nbsp;</span> দিয়ে
                ডিক্লেয়ার করা ভ্যারিয়েবলের
                <span class="text-english">Declaration&nbsp;</span> বা
                <span class="text-english"
                  >Initialization Assignment&nbsp;</span
                >
                কোনোটাই নিজ স্কোপের শুরুতে
                <span class="text-english">Hoisted Up&nbsp;</span> হয় না।
              </p>
              <p>
                আবার একই ফাংশন স্কোপে একই আইডেন্টিফায়ার দিয়ে
                <span class="text-english"><code>var</code>&nbsp;</span>
                ভ্যারিয়েবল রি-ডিক্লেয়ার করলে জাভাস্ক্রিপ্ট কিছু মনে করে না, কেবল
                ইগনোর করে। রি-ডিক্লেয়ারকে আগের ভ্যারিয়েবলের নিছক রেফারেন্স
                হিসেবে ধরে নেয়। অন্যদিকে, একই ব্লক স্কোপে একই আইডেন্টিফায়ার দিয়ে
                <span class="text-english"><code>let</code>&nbsp;</span> ও
                <span class="text-english"><code>const</code>&nbsp;</span>
                ভ্যারিয়েবল রি-ডিক্লেয়ার করলে জাভাস্ক্রিপ্ট সেটাকে সিনট্যাক্স এরর
                বলে ঘোষণা করে।
              </p>
              <p>
                <span class="text-english"><code>var</code>&nbsp;</span> ও
                <span class="text-english"><code>let</code>&nbsp;</span> দিয়ে
                ডিক্লেয়ার করা ভ্যারিয়েবলের মান রানটাইমে যতবার খুশি বা দরকার
                চেঞ্জ/রি-এসাইন করা যায়। অন্যদিকে,
                <span class="text-english"><code>const</code>&nbsp;</span> দিয়ে
                ডিক্লেয়ার করা ভ্যারিয়েবলের মান ডিক্লারেশন স্টেটমেন্টের পরে
                রি-এসাইন করা সিনট্যাক্স এরর।
              </p>
              <p>
                <span class="text-english"><code>var</code>&nbsp;</span> ও
                <span class="text-english"><code>let</code>&nbsp;</span> দিয়ে
                ডিক্লেয়ার করা ভ্যারিয়েবলকে এক্সপ্লিসিটলি ইনিশিয়ালাইজ না করলে,
                এদের ইমপ্লিসিট মান হয়
                <span class="text-english"><code>undefined</code></span
                >। অন্যদিকে,
                <span class="text-english"><code>const</code>&nbsp;</span> দিয়ে
                ডিক্লেয়ার করা ভ্যারিয়েবলকে এক্সপ্লিসিটলি ইনিশিয়ালাইজ না করলে, তা
                সিনট্যাক্স এরর, কারণ
                <span class="text-english"><code>const</code>&nbsp;</span>-এর
                ক্ষেত্রে ডিক্লারেশন স্টেটমেন্টের পরে এসাইন করার সুযোগ নেই।
              </p>
            </div>
          </div>
        </div>
        <div class="accordion-item p-0 col-lg-8 border rounded">
          <h2 class="accordion-header m-0 border-0" id="headingTwo">
            <button
              class="accordion-button collapsed"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#collapseTwo"
              aria-expanded="false"
              aria-controls="collapseTwo"
            >
              <span
                ><strong class="text-english">Global Scope</strong> ও
                <strong class="text-english">Block Scope</strong>— এই দুইটির
                মধ্যে পার্থক্য কী?</span
              >
            </button>
          </h2>
          <div
            id="collapseTwo"
            class="accordion-collapse collapse"
            aria-labelledby="headingTwo"
            data-bs-parent="#faqs"
          >
            <div class="accordion-body">
              <p>
                <span class="text-english">Regular Function&nbsp;</span> যখন
                <span class="text-english">Function Declaration&nbsp;</span>,
                তখন তা <span class="text-english">Named Function&nbsp;</span>।
                <span class="text-english">Regular Function&nbsp;</span> যখন
                <span class="text-english">Function Expression&nbsp;</span>, তখন
                তা <span class="text-english">Named Function&nbsp;</span> বা
                <span class="text-english">Anonymous Function&nbsp;</span>
                দুইটাই হতে পারে। অন্যদিকে,
                <span class="text-english">Arrow Function&nbsp;</span> সদা
                <span class="text-english">Anonymous&nbsp;</span>।
              </p>
              <p>
                <span class="text-english">Regular Function</span>-এর তুলনায়
                <span class="text-english">Arrow Function</span>-এর সিনট্যাক্সে
                বাঁচালতা কম (মানে কী-ওয়ার্ড বা টোকেনের ব্যবহার কম)। যেমন—
                <span class="text-english"><code>function</code>&nbsp;</span>
                কীওয়ার্ড লিখতে হয় না। প্যারামিটার একটা হলে প্যারেন্থিসিস দরকার
                হয় না। আবার কখনো কখনো (কখন? সবাই জানে!) যে ফাংশন বডির ব্র্যাসেস
                ও বডির ভেতরে
                <span class="text-english"><code>return</code>&nbsp;</span>
                কীওয়ার্ড বাদেই ভ্যালু রিটার্ন করা যায়, তাতে কে মুগ্ধ হয় না?
              </p>
              <p>
                <span class="text-english">Regular Function&nbsp;</span> প্রতিটি
                ইনভোকেশনে ইনভোকেশনের ধরণ অনুযায়ী নিজের ভিতরে
                <span class="text-english"><code>this</code>&nbsp;</span>
                কীওয়ার্ডের নিজস্ব মান তৈরি করে। অন্যদিকে,
                <span class="text-english">Arrow Function&nbsp;</span> তা করে
                না— সে সবসময় প্যারেন্ট লেক্সিক্যাল কনটেক্সটের
                <span class="text-english"><code>this</code></span
                >-এর মান ধরে রাখে।
              </p>
              <p>
                নিজস্ব
                <span class="text-english"><code>this</code>&nbsp;</span> তৈরি
                না করার কারণে
                <span class="text-english">Arrow Function&nbsp;</span> কখনো
                <span class="text-english">Object Constructor&nbsp;</span>
                হিসেবে ব্যবহার করা যায় না।
              </p>
              <p>
                <span class="text-english">Regular Function</span>-এর সাথে
                আরেকটা বৈসাদৃশ্য—
                <span class="text-english">Arrow Function</span>-এর ভেতরে
                <span class="text-english"><code>arguments</code>&nbsp;</span>
                বা
                <span class="text-english"><code>super</code></span
                >-এর নিজস্ব বাইন্ডিং নেই।
              </p>
            </div>
          </div>
        </div>
        <div class="accordion-item p-0 col-lg-8 border rounded">
          <h2 class="accordion-header m-0 border-0" id="headingThree">
            <button
              class="accordion-button collapsed"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#collapseThree"
              aria-expanded="false"
              aria-controls="collapseThree"
            >
              <span
                ><strong class="text-english">Event Loop</strong> কীভাবে কাজ
                করে?
              </span>
            </button>
          </h2>
          <div
            id="collapseThree"
            class="accordion-collapse collapse"
            aria-labelledby="headingThree"
            data-bs-parent="#faqs"
          >
            <div class="accordion-body">
              <p>
                এই চারটি মেথডের প্রতিটিই আর্গুমেন্ট হিসেবে একটি করে কলব্যাক
                ফাংশন নেয়।
              </p>
              <p>
                <span class="text-english"><code>map()</code></span
                >,&nbsp; <span class="text-english"><code>forEach()</code></span
                >&nbsp;ও&nbsp;
                <span class="text-english"><code>filter()</code></span> মেথড
                তিনটির প্রত্যেকে প্রদত্ত কলব্যাক ফাংশনটিকে ইনভোকিং এ্যারের
                প্রতিটি (ডিলিটেড বা কখনোই এসাইন করা হয়নি, এমন বাদে) ইলিমেন্টের
                জন্য একবার করে কল করে। অন্যদিকে,
                <span class="text-english"><code>find()</code></span> মেথড
                প্রতিটি ইলিমেন্টের জন্য কলব্যাককে ইনভোক করার আগেই রিটার্ন করতে
                পারে।
              </p>
              <p>
                <span class="text-english"><code>map()</code></span
                >&nbsp; মেথড প্রদত্ত কলব্যাকের রিটার্ন ভ্যালুর মাধ্যমে ইনভোকিং
                এ্যারের প্রতিটি এলিমেন্টকে অন্য ভ্যালুতে পরিণত করে এবং নতুন
                ভ্যালুগুলোকে যথাক্রমে এ্যারে হিসেবে রিটার্ন করে।
              </p>
              <p>
                <span class="text-english"><code>forEach()</code></span
                >&nbsp; মেথড প্রদত্ত কলব্যাকের মাধ্যমে ইনভোকিং এ্যারের প্রতিটি
                এলিমেন্টের প্রেক্ষিতে কোনো এক্‌শন সম্পন্ন করে। কিন্তু কলব্যাকের
                রিটার্ন ভ্যালু ইগনোর করে এবং নিজেও কিছু রিটার্ন করে না (মানে,
                <span class="text-english"><code>undefined</code></span
                >&nbsp; রিটার্ন করে)।
              </p>
              <p>
                <span class="text-english"><code>filter()</code></span
                >&nbsp; মেথড প্রদত্ত কলব্যাককে ইনভোকিং এ্যারের প্রতিটি
                এলিমেন্টের জন্য টেস্টিং ফাংশন হিসেবে ব্যবহার করে। এই মেথড
                কলব্যাকের রিটার্ন ভ্যালুকে
                <span class="text-english">truthy/falsy</span> দৃষ্টিতে বিচার
                করে এবং ইনভোকিং এ্যারের যেসকল এলিমেন্টের জন্য কলব্যাক থেকে
                <span class="text-english">truthy</span> ভ্যালু রিটার্ন পায়,
                সেসকল এলিমেন্টগুলোকে যথাক্রমে একটি এ্যারেতে রিটার্ন করে।
              </p>
              <p>
                <span class="text-english"><code>find()</code></span
                >&nbsp; মেথড
                <span class="text-english"><code>filter()</code></span
                >&nbsp; মেথডের মতই শুরু করে। কিন্তু প্রথম যে এলিমেন্টের জন্য
                কলব্যাক থেকে <span class="text-english">truthy</span> ভ্যালু
                রিটার্ন পায়, সেই এলিমেন্টকে রিটার্ন করেই থেমে যায়,
                <span class="text-english"><code>filter()</code></span
                >&nbsp; মেথডের মত আর সামনে আগায় না। অথবা সব এলিমেন্ট ঘুরেও অমন
                এলিমেন্ট না পেলে
                <span class="text-english"><code>undefined</code></span
                >&nbsp; রিটার্ন করে।
              </p>
            </div>
          </div>
        </div>
        <div class="accordion-item p-0 col-lg-8 border rounded">
          <h2 class="accordion-header m-0 border-0" id="headingFour">
            <button
              class="accordion-button collapsed"
              type="button"
              data-bs-toggle="collapse"
              data-bs-target="#collapseFour"
              aria-expanded="false"
              aria-controls="collapseFour"
            >
              <span>
                জাভাস্ক্রিপ্টে কখন কখন এক্সপ্রেশন ভ্যালু হিসেবে
                <code class="text-english">undefined</code> আসতে পারে?
              </span>
            </button>
          </h2>
          <div
            id="collapseFour"
            class="accordion-collapse collapse"
            aria-labelledby="headingFour"
            data-bs-parent="#faqs"
          >
            <div class="accordion-body">
              <p>
                <span class="text-english">Single Quote String Literal</span
                >&nbsp; বা
                <span class="text-english">Double Quote String Literal</span>-এর
                তুলনায়
                <span class="text-english">Template String Literal</span>&nbsp;
                দিয়ে <span class="text-english">Multiline String</span>&nbsp;
                তৈরি করা সিনট্যাক্টিক্যালি কম বাঁচালতাসম্পন্ন, ফলে সহজতর।
                <span class="text-english">Multiline HTML Element String</span
                >&nbsp; লিখার সময় ব্যাপারটা বিতর্কের বাইরে স্পষ্ট হয়।
              </p>
              <p>
                <span class="text-english">Variable</span>&nbsp; বা জটিলতর
                <span class="text-english">Expression</span>-এর মান যখন ছোট ছোট
                স্ট্রিং-এর সাথে কনকেট করে বড় স্ট্রিং তৈরি করতে হয়, তখন সিঙ্গেল
                কোট বা ডাবল কোট স্ট্রিং ব্যবহার করলে, এই 'কোটের বাইরে যাই' তো,
                এই 'কোটের ভেতরে', 'এখন বাইরে নাকি ভেতরে'— এহেন নানা বিড়ম্বনায় যে
                জ্বলেছে, সে বুঝে। অন্যদিকে,
                <span class="text-english">Template String Literal</span>&nbsp;
                ব্যবহার করলে,যতই
                <span class="text-english">Variable</span>&nbsp; বা
                <span class="text-english">Expression</span>-এর মান রেজাল্টিং
                স্ট্রিং-এ ইন্টারপোলেট করা লাগুক না কেন, আমরা পুরো সময় এক জোড়া
                ব্যাকটিকের পরম মমতায়।
              </p>
            </div>
          </div>
        </div>
      </div>
    </main>
  </body>
</html>
